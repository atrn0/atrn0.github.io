<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="この記事は、CAMPHOR- Advent Calendar 2021 の15日目の記事です。
ラムダ計算とは、関数定義と関数の適用からなるプログラミング言語で、チューリング完全な計算モデルです。以前ラムダ計算のインタプリタをOCamlで実装しました。この記事ではそのインタプリタでnの階乗を求めるまでの道のりを書きます。
実装したインタプリタは以下にあります。
https://github.com/atrn0/lambda
動機 僕が所属している研究室では、B4の前期にTypes and Programming Languagesの輪読と数学演習、OCamlとCoqの演習をやります。OCaml演習では基本的にB3でやるインタプリタ実験の続きをやります。
 OCaml 演習は，実験3SWの続きをやってみてください． &amp;hellip; あとは，OCaml で面白いソフトウェア（できれば言語処理系？）を実装してみるのもよいかもしれません．
 プログラミング言語処理系という授業を落として再履修していた僕は、この授業の課題としてインタプリタ実験の続きはどうせやるので、「面白いソフトウェア（できれば言語処理系？）」も実装することにしました。題材の言語は、TaPLの輪講でちょうど読んでいて、性質が面白いかつ処理系の実装が簡単そうな型無しラムダ計算を選びました。
(型無し)ラムダ計算 複雑なプログラミング言語が、その本質的な仕組みを表現できる核となる計算モデルと、その核に変換される派生形式の集まりとして定式化できるという考え方があります。その一つの計算モデルがラムダ計算で、Lisp, Scheme, MLなどの言語の核となる計算モデルです。他にも$\pi$計算やオブジェクト計算などの計算モデルがあり、それぞれメッセージベースの並行処理言語、オブジェクト指向言語の核となる機能を持っています。これらの計算モデルはそれ自体で計算が記述できる単純なプログラミング言語であるのと同時に、数学的対象としてもみなせるので、一般的なプログラミング言語の仕様の記述や、設計、実装、研究において広く使われています。
ラムダ計算では全ての計算が関数の定義と適用に帰着されます。実装したインタプリタで扱える型無しラムダ計算の文法と意味論(プログラムがどう評価されるか)を見ていきます。
文法(シンタックス) プログラムの文法は以下です。
t ::= | x (変数) | \x. t (関数定義) | t t (関数適用) これはBNF風の記法で書いていて、tはxまたは\x. tまたはt tであるという意味です。右辺のtは左辺のtで、関数定義のxは任意の変数で置き換えることができます。それと、カッコは適当につけることができます。
例えば、以下のようなプログラムが許容されます。
 y: 1つの変数y \y. y: yを引数として受け取り、yを返す関数(恒等関数) f x: 引数xを関数fに適用する \x. f x: xを引数として受け取り、fに適用して返す関数 \x. (\x. x) x: xを引数として受け取り、恒等関数に適用して返す関数  このように、基本的に関数の定義と適用のみを使ってプログラムを書きます。
また、関数適用は左結合で、関数適用は関数定義より優先されます。つまり、
 x y zというプログラムは(x y) zと等価 (左結合) \x."><title>自作ラムダ計算インタプリタで階乗を計算する</title><link rel=canonical href=https://atrn0.github.io/p/lambda-interpreter/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="自作ラムダ計算インタプリタで階乗を計算する"><meta property="og:description" content="この記事は、CAMPHOR- Advent Calendar 2021 の15日目の記事です。
ラムダ計算とは、関数定義と関数の適用からなるプログラミング言語で、チューリング完全な計算モデルです。以前ラムダ計算のインタプリタをOCamlで実装しました。この記事ではそのインタプリタでnの階乗を求めるまでの道のりを書きます。
実装したインタプリタは以下にあります。
https://github.com/atrn0/lambda
動機 僕が所属している研究室では、B4の前期にTypes and Programming Languagesの輪読と数学演習、OCamlとCoqの演習をやります。OCaml演習では基本的にB3でやるインタプリタ実験の続きをやります。
 OCaml 演習は，実験3SWの続きをやってみてください． &amp;hellip; あとは，OCaml で面白いソフトウェア（できれば言語処理系？）を実装してみるのもよいかもしれません．
 プログラミング言語処理系という授業を落として再履修していた僕は、この授業の課題としてインタプリタ実験の続きはどうせやるので、「面白いソフトウェア（できれば言語処理系？）」も実装することにしました。題材の言語は、TaPLの輪講でちょうど読んでいて、性質が面白いかつ処理系の実装が簡単そうな型無しラムダ計算を選びました。
(型無し)ラムダ計算 複雑なプログラミング言語が、その本質的な仕組みを表現できる核となる計算モデルと、その核に変換される派生形式の集まりとして定式化できるという考え方があります。その一つの計算モデルがラムダ計算で、Lisp, Scheme, MLなどの言語の核となる計算モデルです。他にも$\pi$計算やオブジェクト計算などの計算モデルがあり、それぞれメッセージベースの並行処理言語、オブジェクト指向言語の核となる機能を持っています。これらの計算モデルはそれ自体で計算が記述できる単純なプログラミング言語であるのと同時に、数学的対象としてもみなせるので、一般的なプログラミング言語の仕様の記述や、設計、実装、研究において広く使われています。
ラムダ計算では全ての計算が関数の定義と適用に帰着されます。実装したインタプリタで扱える型無しラムダ計算の文法と意味論(プログラムがどう評価されるか)を見ていきます。
文法(シンタックス) プログラムの文法は以下です。
t ::= | x (変数) | \x. t (関数定義) | t t (関数適用) これはBNF風の記法で書いていて、tはxまたは\x. tまたはt tであるという意味です。右辺のtは左辺のtで、関数定義のxは任意の変数で置き換えることができます。それと、カッコは適当につけることができます。
例えば、以下のようなプログラムが許容されます。
 y: 1つの変数y \y. y: yを引数として受け取り、yを返す関数(恒等関数) f x: 引数xを関数fに適用する \x. f x: xを引数として受け取り、fに適用して返す関数 \x. (\x. x) x: xを引数として受け取り、恒等関数に適用して返す関数  このように、基本的に関数の定義と適用のみを使ってプログラムを書きます。
また、関数適用は左結合で、関数適用は関数定義より優先されます。つまり、
 x y zというプログラムは(x y) zと等価 (左結合) \x."><meta property="og:url" content="https://atrn0.github.io/p/lambda-interpreter/"><meta property="og:site_name" content="atrn0"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="CAMPHOR- Advent Calendar"><meta property="article:published_time" content="2021-12-15T00:00:00+09:00"><meta property="article:modified_time" content="2021-12-15T00:00:00+09:00"><meta name=twitter:site content="atrn0"><meta name=twitter:title content="自作ラムダ計算インタプリタで階乗を計算する"><meta name=twitter:description content="この記事は、CAMPHOR- Advent Calendar 2021 の15日目の記事です。
ラムダ計算とは、関数定義と関数の適用からなるプログラミング言語で、チューリング完全な計算モデルです。以前ラムダ計算のインタプリタをOCamlで実装しました。この記事ではそのインタプリタでnの階乗を求めるまでの道のりを書きます。
実装したインタプリタは以下にあります。
https://github.com/atrn0/lambda
動機 僕が所属している研究室では、B4の前期にTypes and Programming Languagesの輪読と数学演習、OCamlとCoqの演習をやります。OCaml演習では基本的にB3でやるインタプリタ実験の続きをやります。
 OCaml 演習は，実験3SWの続きをやってみてください． &amp;hellip; あとは，OCaml で面白いソフトウェア（できれば言語処理系？）を実装してみるのもよいかもしれません．
 プログラミング言語処理系という授業を落として再履修していた僕は、この授業の課題としてインタプリタ実験の続きはどうせやるので、「面白いソフトウェア（できれば言語処理系？）」も実装することにしました。題材の言語は、TaPLの輪講でちょうど読んでいて、性質が面白いかつ処理系の実装が簡単そうな型無しラムダ計算を選びました。
(型無し)ラムダ計算 複雑なプログラミング言語が、その本質的な仕組みを表現できる核となる計算モデルと、その核に変換される派生形式の集まりとして定式化できるという考え方があります。その一つの計算モデルがラムダ計算で、Lisp, Scheme, MLなどの言語の核となる計算モデルです。他にも$\pi$計算やオブジェクト計算などの計算モデルがあり、それぞれメッセージベースの並行処理言語、オブジェクト指向言語の核となる機能を持っています。これらの計算モデルはそれ自体で計算が記述できる単純なプログラミング言語であるのと同時に、数学的対象としてもみなせるので、一般的なプログラミング言語の仕様の記述や、設計、実装、研究において広く使われています。
ラムダ計算では全ての計算が関数の定義と適用に帰着されます。実装したインタプリタで扱える型無しラムダ計算の文法と意味論(プログラムがどう評価されるか)を見ていきます。
文法(シンタックス) プログラムの文法は以下です。
t ::= | x (変数) | \x. t (関数定義) | t t (関数適用) これはBNF風の記法で書いていて、tはxまたは\x. tまたはt tであるという意味です。右辺のtは左辺のtで、関数定義のxは任意の変数で置き換えることができます。それと、カッコは適当につけることができます。
例えば、以下のようなプログラムが許容されます。
 y: 1つの変数y \y. y: yを引数として受け取り、yを返す関数(恒等関数) f x: 引数xを関数fに適用する \x. f x: xを引数として受け取り、fに適用して返す関数 \x. (\x. x) x: xを引数として受け取り、恒等関数に適用して返す関数  このように、基本的に関数の定義と適用のみを使ってプログラムを書きます。
また、関数適用は左結合で、関数適用は関数定義より優先されます。つまり、
 x y zというプログラムは(x y) zと等価 (左結合) \x."><link rel=apple-touch-icon sizes=57x57 href=/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$']],
      processEnvironments: true
    }
  });
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type=text/javascript></script></head><body class="article-page keep-sidebar"><div class="container flex on-phone--column align-items--flex-start extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hud6a86d7d4ad6658ce6dd421e57e49f0d_272571_300x300_resize_box_2.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>🤔</span></figure><h1 class=site-name><a href=https://atrn0.github.io>atrn0</a></h1><h2 class=site-description>CS Student. B4</h2><ul class=social><li class=social-item><a href=https://www.facebook.com/atrn0 target=_blank rel=noreferrer><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="1" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 10v4h3v7h4v-7h3l1-4h-4V8a1 1 0 011-1h3V3h-3a5 5 0 00-5 5v2H7"/></svg></a></li><li class=social-item><a href=https://github.com/atrn0 target=_blank rel=noreferrer><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="1" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0c-2.4-1.6-3.5-1.3-3.5-1.3a4.2 4.2.0 00-.1 3.2 4.6 4.6.0 00-1.3 3.2c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li class=social-item><a href=https://twitter.com/atrn0 target=_blank rel=noreferrer><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="1" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ul></header><ol class=menu id=main-menu><li><a href=https://atrn0.github.io/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=https://atrn0.github.io/about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=https://atrn0.github.io/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><h2 class=article-title><a href=https://atrn0.github.io/p/lambda-interpreter/>自作ラムダ計算インタプリタで階乗を計算する</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Dec 15, 2021</time></footer></div></header><section class=article-content><p>この記事は、<a class=link href=https://advent.camph.net/ target=_blank rel=noopener>CAMPHOR- Advent Calendar 2021</a> の15日目の記事です。</p><p>ラムダ計算とは、関数定義と関数の適用からなるプログラミング言語で、チューリング完全な計算モデルです。以前ラムダ計算のインタプリタをOCamlで実装しました。この記事ではそのインタプリタでnの階乗を求めるまでの道のりを書きます。</p><p>実装したインタプリタは以下にあります。</p><p><a href=https://github.com/atrn0/lambda>https://github.com/atrn0/lambda</a></p><h2 id=動機>動機</h2><p>僕が所属している研究室では、B4の前期に<a class=link href=https://www.cis.upenn.edu/~bcpierce/tapl/ target=_blank rel=noopener>Types and Programming Languages</a>の輪読と数学演習、OCamlとCoqの演習をやります。OCaml演習では基本的にB3でやるインタプリタ実験の続きをやります。</p><blockquote><p>OCaml 演習は，実験3SWの続きをやってみてください． &mldr; あとは，OCaml で面白いソフトウェア（できれば言語処理系？）を実装してみるのもよいかもしれません．</p></blockquote><p>プログラミング言語処理系という授業を落として再履修していた僕は、この授業の課題としてインタプリタ実験の続きはどうせやるので、「面白いソフトウェア（できれば言語処理系？）」も実装することにしました。題材の言語は、TaPLの輪講でちょうど読んでいて、性質が面白いかつ処理系の実装が簡単そうな型無しラムダ計算を選びました。</p><h2 id=型無しラムダ計算>(型無し)ラムダ計算</h2><p>複雑なプログラミング言語が、その本質的な仕組みを表現できる核となる計算モデルと、その核に変換される派生形式の集まりとして定式化できるという考え方があります。その一つの計算モデルがラムダ計算で、Lisp, Scheme, MLなどの言語の核となる計算モデルです。他にも$\pi$計算やオブジェクト計算などの計算モデルがあり、それぞれメッセージベースの並行処理言語、オブジェクト指向言語の核となる機能を持っています。これらの計算モデルはそれ自体で計算が記述できる単純なプログラミング言語であるのと同時に、数学的対象としてもみなせるので、一般的なプログラミング言語の仕様の記述や、設計、実装、研究において広く使われています。</p><p>ラムダ計算では全ての計算が関数の定義と適用に帰着されます。実装したインタプリタで扱える型無しラムダ計算の文法と意味論(プログラムがどう評価されるか)を見ていきます。</p><h3 id=文法シンタックス>文法(シンタックス)</h3><p>プログラムの文法は以下です。</p><pre><code>t ::=
  | x     (変数)
  | \x. t (関数定義)
  | t t   (関数適用)
</code></pre><p>これはBNF風の記法で書いていて、<code>t</code>は<code>x</code>または<code>\x. t</code>または<code>t t</code>であるという意味です。右辺の<code>t</code>は左辺の<code>t</code>で、関数定義の<code>x</code>は任意の変数で置き換えることができます。それと、カッコは適当につけることができます。</p><p>例えば、以下のようなプログラムが許容されます。</p><ul><li><code>y</code>: 1つの変数y</li><li><code>\y. y</code>: yを引数として受け取り、yを返す関数(恒等関数)</li><li><code>f x</code>: 引数xを関数fに適用する</li><li><code>\x. f x</code>: xを引数として受け取り、fに適用して返す関数</li><li><code>\x. (\x. x) x</code>: xを引数として受け取り、恒等関数に適用して返す関数</li></ul><p>このように、基本的に関数の定義と適用のみを使ってプログラムを書きます。</p><p>また、関数適用は左結合で、関数適用は関数定義より優先されます。つまり、</p><ul><li><code>x y z</code>というプログラムは<code>(x y) z</code>と等価 (左結合)</li><li><code>\x. y z</code>というプログラムは<code>(\x. y) z</code>ではなく<code>\x. (y z)</code>と等価 (関数適用を優先)</li></ul><p>とします。</p><h3 id=意味論セマンティクス>意味論(セマンティクス)</h3><p>次に、プログラムとして入力した文字列がインタプリタにどのように評価(解釈)されるかを決める必要があります。</p><p>ラムダ計算では、「<code>(\x. s) t</code> という形が来たら、sの中に出てくるxをtで置き換える」(ベータ簡約) という方針でプログラムを変換します。この変換によってプログラムが評価、計算されます。例えば、プログラムは以下のように変換されます。</p><p>(\x.x) (<strong>(\x.x) (\z. (\x.x) z)</strong>)<br>→ <strong>(\x. x) (\z. ((\x. x) z))</strong><br>→ \z. (<strong>(\x. x) z</strong>)<br>→ \z. z</p><p>実装したインタプリタでは、<code>(\x. s) t</code> という形がなくなるまでこの操作を繰り返すことにします。</p><h2 id=計算の例>計算の例</h2><p>ここまででプログラミング言語を定義することができました。この言語を使って早速プログラムを書いて実行したいところですが、この言語には数値、算術演算、条件式、レコード、ループ、列など、一般的な言語に備わっていそうな機能は何もありません🥺。ないものは仕方ないので、今の言語機能でなんとかすることにします。</p><p>とりあえずnの階乗を求めることを目標にします。nの階乗を求める関数は、例えばCだと以下のように書けます。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=n>f</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>nの階乗を求めるために必要そうな要素は、</p><ul><li>条件分岐</li><li>数</li><li>乗算</li><li>再帰演算</li></ul><p>などです。1つずつ作っていきます。</p><h3 id=条件分岐>条件分岐</h3><p>まず、条件分岐をするためにブール値が欲しいです。<code>true</code>や<code>false</code>というプリミティブな定数はないので、代わりにこれらを関数にエンコードします。</p><pre><code>true  = \t. \f. t
false = \t. \f. f
</code></pre><p><code>true</code>は2つの引数を受け取って1つ目の引数を返す関数、<code>false</code>は2つ目の引数を返す関数です。(複数引数の関数はカリー化によって高階関数に変換します。) このようにエンコードすると、条件分岐は以下のように書けます。</p><pre><code>test = \l. \m. \n. l m n
</code></pre><p><code>test</code>は3つの引数l, m, nを受け取って、lが<code>true</code>のときmを、<code>false</code>のときnを返す関数です。</p><p>例えば、<code>test true x y</code>というプログラムは、</p><p>= <strong>(\l. \m. \n. l m n) (\t. \f. t)</strong> x y<br>→ <strong>(\m. \n. (\t. \f. t) m n) x</strong> y<br>→ <strong>(\n. (\t. \f. t) x n) y</strong><br>→ (<strong>(\t. \f. t) x</strong>) y<br>→ <strong>(\f. x) y</strong><br>→ x</p><p>と評価され、確かにxになります。</p><h3 id=数>数</h3><p>次に数をエンコードします。</p><pre><code>0 = \s. \z. z
1 = \s. \z. s z
2 = \s. \z. s (s z)
3 = \s. \z. s (s (s z))
...
</code></pre><p>このように、自然数nは2つの引数s, zを受け取り、sをzにn回適用する関数として表します。このエンコード方法はチャーチ数と呼ばれます。</p><p>この数を使うと、例えば加算、乗算は</p><pre><code>plus = \m. \n. \s. \z. m s (n s z)
times = \m. \n. m (plus n) 0
</code></pre><p>と書けます。</p><h3 id=再帰演算>再帰演算</h3><p>再帰演算は不動点コンビネータと呼ばれる関数を使って行います。不動点コンビネータとは、ラムダ計算の過程で<code>fix g → g (fix g)</code>と変換されるような関数<code>fix</code>のことです。</p><p>例えば、<code>f = \n. f n</code>のような再帰関数を使った演算は、引数に<code>f</code>をとる関数gを使って以下のように行うことができます。</p><pre><code>g = \f. \n. f n
(fix g) i
→ g (fix g) i
= (\f. \n. f n) (fix g) i
→ (\n. (fix g) n) i
...
</code></pre><p>このように、<code>(fix g)</code>が再帰的に関数内に現れるように変換できます。</p><h3 id=階乗の計算>階乗の計算</h3><p>以上のように、一般的な言語に備わっている機能をラムダ計算にエンコードすることができます。実装したインタプリタでは、階乗の計算を行うために以下のようなマクロを定義しています。</p><div class=highlight><pre class=chroma><code class=language-ocaml data-lang=ocaml><span class=k>let</span> <span class=n>initial_env</span> <span class=o>=</span> <span class=nn>Environment</span><span class=p>.</span><span class=n>from_list</span> <span class=o>[</span>
  <span class=o>(</span><span class=s2>&#34;test&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λl. λm. λn. l m n&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;tru&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λt. λf. t&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;fls&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λt. λf. f&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;iszro&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λm. m (λx. fls) tru&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;c0&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λs. λz. z&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;c1&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λs. λz. s z&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;plus&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λm. λn. λs. λz. m s (n s z)&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;times&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λm. λn. m (plus n) c0&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;pair&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λf. λs. λb. b f s&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;fst&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λp. p tru&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;snd&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λp. p fls&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;prd&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λm. fst (m (λp. pair (snd p) (plus c1 (snd p))) (pair c0 c0))&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;fix&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;λf. (λx. f (λy. x x y)) (λx. f (λy. x x y))&#34;</span><span class=o>);</span>
  <span class=o>(</span><span class=s2>&#34;factorial&#34;</span><span class=o>,</span> <span class=n>parse</span> <span class=s2>&#34;fix (λf. λn. test (iszro n) (λx. c1) (λx. (times n (f (prd n)))) c0)&#34;</span><span class=o>);</span>
<span class=o>]</span>
</code></pre></div><p><code>factorial</code>が階乗を計算する関数です。<code>factorial</code>の中身を見てみると、不動点コンビネータ<code>fix</code>を用いて<code>f</code>が関数内で再帰的に使える構造になっていることがわかります。まず<code>test</code>を用いてnが0かどうか(<code>iszro n</code>)で条件分岐しています。nが0の場合は<code>λx. c1</code>が、そうでない場合は<code>λx. (times n (f (prd n)))) c0</code>が計算結果になります。後者の場合は<code>times</code>を用いて<code>n</code>と、<code>prd n</code> (n - 1) を<code>f</code>に適用した数の積が計算されます。</p><p>例えば4の階乗を求めるためには次のようなプログラムを実行します。</p><pre><code># factorial (times (scc c1) (scc c1))
→ (λs. (λz. (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s z))))))))))))))))))))))))))
</code></pre><p>sが24個並んでいるので、無事4の階乗を求めることができました🎉</p><p>因みに、インタプリタにはverboseモードがあり、プログラムが変換される様子をみることができます。</p><p><a class=link href=https://gyazo.com/3ba78b4d753b025e02e8ff712f2485e3 target=_blank rel=noopener><img src=https://i.gyazo.com/3ba78b4d753b025e02e8ff712f2485e3.gif alt="Image from Gyazo"></a></p><h2 id=さいごに>さいごに</h2><p>インタプリタの解説というよりラムダ計算の説明が大部分になってしまいましたが、単純な計算体系で実用的な計算ができるという面白さが伝わっていたら幸いです。</p></section><footer class=article-footer><section class=article-tags><a href=https://atrn0.github.io/tags/camphor-advent-calendar/>CAMPHOR- Advent Calendar</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload="renderMathInElement(document.querySelector(`.article-content`));"></script></article><footer class=site-footer><section class=copyright>&copy; 2021 atrn0</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=1.0.5>Stack</a></b> designed by
<a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true style=display:none><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script><link rel=stylesheet href=/css/highlight/light.min.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=/css/highlight/dark.min.css media="(prefers-color-scheme: dark)"></body></html>